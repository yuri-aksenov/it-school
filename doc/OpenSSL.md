# Домашнее задание по OpenSSL и WebRTC

<https://ru.wikipedia.org/wiki/OpenSSL>

<https://ru.wikipedia.org/wiki/WebRTC>

Напишите программу на C++, которая использует библиотеку OpenSSL для работы с сертификатами.

Тут основной упор на подключение и использование сторонней библиотеке на C, а наш язык разработки C++. Надо изучить API и самостоятельно написать RAII обертку над библиотечными вызовами OpenSSL.

<https://ru.wikipedia.org/wiki/Получение_ресурса_есть_инициализация>

Не пишите в стиле C. Для владения ресурсами X509, BIO из библиотеки OpenSSL используйте std::unique_ptr с переопределенными deleter'ами.

```c++
#include <memory>
#include <openssl/pem.h>
#include <openssl/x509.h>

std::unique_ptr<BIO, decltype(&BIO_free)> cert{BIO_new_file("cert.pem", "rb"), &BIO_free};
std::unique_ptr<X509, decltype(&X509_free)> x509{PEM_read_bio_X509(cert.get(), NULL, NULL, NULL), &X509_free};

int main()
{
  // здесь нужно добавить код
  return EXIT_SUCCESS;
}
```

Для работы программы нужно локально иметь файл сертификата cert.pm, его можно сгенерировать командой:
```bash
openssl req -x509 -newkey rsa:2048 -days 3650 -nodes -keyout key.pem -out cert.pem
```

Также командой можно посчитать Fingerprint (digest) сертификата:
```bash
openssl x509 -noout -in cert.pem -fingerprint -sha256
```

Получится что-то вроде:
```
SHA256 Fingerprint=11:43:BA:B5:37:5B:DF:58:87:E3:4B:C6:AA:66:B2:F0:54:CC:31:66:92:30:C8:98:A6:FF:87:06:9D:49:89:A5
```

Первое задание изучить API OpenSSL и программно посчитать figerprint сертификата, значение должно получиться такое же, как и в результате выполнения консольной команды.

Вот подсказка, как посчитать дайджест:
```c++
unsigned int n;
unsigned char md[EVP_MAX_MD_SIZE];
X509_digest(x509.get(), EVP_sha256(), md, &n);
```

В примере выше используются глобальные объекты cert и x509, как правило, это плохой стиль, старайтесь избегать глобальных объектов, оформите их членами класса и создавайте объект в main.

В дальнейшем эта программа будет развиваться:
- Будем генерировать сертификаты программно
- Будем работать по сети с TLS пакетами
- Если кто-то далеко зайдет, попробуем написать мини-WebRTC сервер, связывающий два браузера через себя. Но для этого придется к проекту подключать намного больше сторонних библиотек, а также немного уметь в Web :)